<HTML>
<Body>


<form id="frm1">
  Initial Latitude:   <br> <input type="text" name="lat0" id=lat0 ><br>
  Initial Longitude:  <br> <input type="text" name="lon0" id=lon0 ><br>
  Final Latitude:     <br> <input type="text" name="lat1" id=lat1 ><br>
  Final Longitude:    <br> <input type="text" name="lon1" id=lon1 ><br>
  Heading:            <br> <input type="text" name="hdg" id=hdg ><br>
  Num of Waypoints:   <br> <input type="text" name="points" id=points ><br>
</form> 

<p></p>
<button onclick="myFunction()">List Below!</button>
<button onclick="Arc()">Go!</button>

<p id="demo"></p>

<script>
function myFunction() {
  var x = document.getElementById("frm1");
  var text = "";
  var i;
  for (i = 0; i < x.length ;i++) {
    text += x.elements[i].value + "<br>";}
  
  document.getElementById("demo").innerHTML = text;}
  
function GetValues() {
  var lat0 = document.getElementById("lat0").value;
  var lat1 = document.getElementById("lat1").value;
  var lon0 = document.getElementById("lon0").value;
  var lon1 = document.getElementById("lon1").value;
  var heading = document.getElementById("hdg").value;
  var points = document.getElementById("points").value;
  var nL = "\r\n"
  alert(lat0 + nL + lat1 + nL + lon0 + nL + lon1 + nL + heading + nL + points)}
  
function Arc() {
/*
KSAN
var lat0=32.48;
var lon0=-116.97;
var lat1=32.68
var lon1=-116.97;
var heading=90;
Reno
TIPYO 39.2753/-120.1672
SPOON 39.1072/-119.7703
*/
var lat0= 39.2753;
var lon0= -120.1672;
var lat1=  39.1072;
var lon1=  -119.7703;
var heading= 221;

var output = "Hello World!"
var newline = "/r/n"

const println = (msg) => {
  console.log(msg);
}

class Node
{
  constructor(name,value,attribute)
  {
    this.Name = name; 
    this.Value = "";
    if (typeof(value) != "undefined")
      this.Value = value;
    this.Attribute = "";
    if (typeof(attribute)!="undefined")
      this.Attribute=" "+attribute;
    this.Children=[];
    this.Indent="";
    this.Version = "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
  }
  AddChild(child)
  {
    child.Version="";
    child.Indent+=this.Indent+"  ";
    this.Children.push(child);
    return child;
  }
  Exists(name,value)
  {
    if (this.Name==name && this.Value==value)
      return true;
    var i=0;
    while(i<this.Children.length)
    {
      if (this.Children[i].Exists(name,value))
        return true;
      i++;
    }
    return false;
  }
  ToXML()
  {
    //println("building "+this.Name)
    var ret = this.Version;
    ret += this.BuildElement();
    var i=0;
    while (i<this.Children.length)
    {
       ret += this.Children[i].ToXML();
       i++;
    }
    if (this.Children.length!=0)
      ret+=this.Indent+"</"+this.Name+">\n";
    return ret;
  }
  BuildElement()
  {
    var el = this.Indent+"<"+this.Name+this.Attribute+">"+this.Value;
    if (this.Children.length==0)
      el += "</"+this.Name+">\n";
    else
      el += "\n";
    return el;
  }
}


class FlightPlan
{
  constructor(name)
  {
    this.Name=name;
    this.Fp = new Node("flight-plan","", "xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www8.garmin.com/xmlschemas/FlightPlan/v1\"");
    this.WaypointTable = new Node("waypoint-table","");
    this.RouteTable = new Node("route","");
    this.Fp.AddChild(this.WaypointTable);
    this.Fp.AddChild(this.RouteTable);
  }
  AddUserFix(id,lat,lon)
  {
    if (!this.WaypointTable.Exists("identifier",id))
    {
      var wp = new Node("waypoint","");
      this.WaypointTable.AddChild(wp);
      wp.AddChild(new Node("identifier",id));
      wp.AddChild(new Node("type","USER WAYPOINT"));
      wp.AddChild(new Node("lat",lat));
      wp.AddChild(new Node("lon",lon));
    }
    var rt = new Node("route-point","");
    this.RouteTable.AddChild(rt);
    rt.AddChild(new Node("waypoint-identifier",id));
    rt.AddChild(new Node("waypoint-type","USER WAYPOINT"));
  }
  PrintXml()
  {
    println(this.Fp.ToXML());
  }
}

var points=10;


var lonscale = LonMultiplier((lat0+lat1)/2);
//println("LonMultiplier="+lonscale);
var dx = (lon1-lon0)*lonscale;
var dy = lat1-lat0;
//println(dx + "," + dy);

// find the distance and heading to the final fix
dh = DistHeading(lat0,lon0,lat1,lon1);

var headingToFinal=dh[1];
var distToFinal=dh[0];


// verify final fix with distance and heading from initial fix
check = NewPoint(lat0,lon0,headingToFinal,distToFinal);
//println("final from initial given heading and distance..");
ToIF(check[0],check[1]);
//println();

// find the arc radius
alpha = FixHeading(90 - Math.abs(heading - headingToFinal))%360;
//println("alpha="+alpha)
var arcR = Math.abs(dh[0]/(2*Math.cos(alpha*Math.PI/180)));
//println("Arc Radius="+arcR)

// find lat lon of arc center
// first determine the direction
var dir1=heading-90;
var dir2=heading+90;
var headingToCenter=dir2;
var turnLeft=false;
if (AngleBetween(headingToFinal,dir1)<AngleBetween(headingToFinal,dir2))
{
  headingToCenter=dir1;
  turnLeft=true;
  //println("turning left");
}
var arcCenterDec = NewPoint(lat0,lon0,headingToCenter,arcR);
var initialArcHeading = FixHeading(headingToCenter-180);


// find swept angle and setup increment
var headingfixangle=AngleBetween(heading,headingToFinal);

var arcAngle=2*(90-AngleBetween(initialArcHeading,headingToFinal+180));
if (headingfixangle>90)
{
  //println("obtuse angle between heading & fix path")
  arcAngle=2*(90+AngleBetween(initialArcHeading,headingToFinal+180));
}
else
// *********************************** DO NOT DELETE **************************************
  println("acute angle between heading & fix path")

var deltaAngle = arcAngle/points;
var initialArcangle = FixHeading(headingToCenter+180);

var decPoints = [];
if (turnLeft)
{
  var lastAngle = initialArcangle-arcAngle-deltaAngle+1;

  for (h= initialArcangle;h>lastAngle;h-=deltaAngle)
  {
    var arcPoint = NewPoint(arcCenterDec[0],arcCenterDec[1],h,arcR);
    decPoints.push(arcPoint);
    ToIF(arcPoint[0],arcPoint[1]);
   
  }
}
else
{
  var lastAngle = initialArcangle +arcAngle+deltaAngle-1;
  for (h= initialArcangle;h<lastAngle;h+=deltaAngle)
  {
    var arcPoint = NewPoint(arcCenterDec[0],arcCenterDec[1],h,arcR);
    decPoints.push(arcPoint);
    ToIF(arcPoint[0],arcPoint[1]);
    //print(" ")
  }
}
println();

var fp = new FlightPlan("KSAN Circle");
/*
fp.AddUserFix("2400N/11600W","24.000","-116.000");
fp.AddUserFix("2500N/11600W","25.000","-116.000");
fp.AddUserFix("3997N/11816W","33.9744","-118.1622");
fp.PrintXml();
*/
println("Decimal fixes...");
for (index=0;index<decPoints.length;index++)
{
  var lat = decPoints[index][0].toFixed(4);
  var lon = decPoints[index][1].toFixed(4);
  //print(lat+"/"+lon+" ");
  var id = (lat*1000).toFixed(0) +"/"+ (lon*1000).toFixed(0);
  fp.AddUserFix(id,lat,lon);
}
println();
println("XML Flightplan");
fp.PrintXml();

/////////////////////////////////////////////////////
// returns the angle between two headings
function AngleBetween(heading1,heading2)
{
  var h1=FixHeading(heading1);
  var h2=FixHeading(heading2);
  var delta=h1>h2?h1-h2:h2-h1;
  if (delta>180)
    delta=360-delta;
  //println("heading1="+heading1+" heading2="+heading2);
  //println("fxedheading1="+h1+" fixedheading2="+h2+" delta="+delta);
  return delta;
}

// returns degrees minutes (DDDMM) given decimal degrees (DD.dd)
function ToDegMin(num)
{
  var deg = Math.trunc(num);
  var min = Math.round(60*(num-deg));
  
  if (Math.abs(min)==60)
  {
    min=0;
    if (num < 0)
    {
      deg=deg-1;
    }
    else
    {
      deg=deg+1;
    }
  }
  
  /*
  println("debug ToDegMin")
  println("num="+num+" deg="+deg+" min="+min);
  println("end debug")
  */
  return deg*100 + min;
}

// converts lat lon in decimal degrees to DDMM[N/S]/DDDMM[E/W] format IF uses and prints the result
// lat is always entered as N (S is negative)
// lon is entered as E (west is negative)
function ToIF(latitude,longitude)
{
  if (latitude<0)
  {
    //print(ToDegMin(latitude*-1));
    //print('S/');
  }
  else
  {
   // print(ToDegMin(latitude));
   // print('N/');
  }
 
  if (longitude <0)
  {
   // print(ToDegMin(longitude*-1));
   // print('W');
  }
  else
  {
   // print(ToDegMin(longitude));
   // print('E');
  }
}

// returns a longitude scaling factor for the given latitude. 
function LonMultiplier(latitude)
{
  return 1/Math.sin((90-latitude)*Math.PI*2/360);
}

// small headings around 0 are returned as 0
// headings larger than 360 are reduced to a value less than 360
// negative headings are converted to a positive number
function FixHeading(fixthis)
{
  var h = fixthis;
  if (Math.abs(h) < .1) 
    return 0;
  if ((Math.abs(h) / 360) >= 1)
    h = h % 360;
  if (h < 0)
  {
    return 360 + h;
  } 
  return h;
}

// debug print “label:number “
function MyPrint(label, number)
{
  //print(label);
  //print(': ');
  //print(number);
}

function MyPrintf(label, number, length, decimals)
{
  //print(label);
  //print(': ');

}

// given latitude and longitude (decimal degrees) heading and leg length, returns lat lon at the end of the leg
function NewPoint(latitude,longitude,heading,leglength)
{
  var lonScale = LonMultiplier(latitude);
  //var scsle = lonScale;
  var alpha = Math.PI * 2 * (90 - heading)/360;

  var dx = lonScale * leglength * Math.cos(alpha);
  var deltaLon = dx / 60;
  var newLon = longitude + deltaLon;

  var dy = leglength * Math.sin(alpha);
  var deltaLat = dy / 60;
  var newLat = latitude + deltaLat;
  
  /*
  println();
  println("NewPoint debug");
  println("heading="+heading+" legLength="+leglength);
  println("lat="+latitude+" lon="+longitude);
  println("dlat="+deltaLat+" dlon="+deltaLon);
  println("dy="+dy+" dx="+dx);
  println("newLat="+newLat+" newLon="+newLon)
  println("end debug");
  */
  return [newLat,newLon];
}

function DistHeading(latfrom,lonfrom,latto,lonto)
{
   var lonMult = LonMultiplier((latfrom+latto)/2);
   var dy = (latto-latfrom)*60;
   var dx = ((lonto-lonfrom) / lonMult)* 60;
  
   var dist = Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2));
   if (dx==0)
      dx = .000001;
   var dyx=dy/dx;
   var angleRadians = Math.atan(dyx);
   var angleDegrees = angleRadians*180/Math.PI;
   var heading = FixHeading(90-angleDegrees); 
   if (dx<0 && dy<0)
      heading = 180+angleDegrees;
   else if (dx<0 && dy>=0)
      heading = 270-angleDegrees;
   
   //println("lonMult="+lonMult+" dx="+dx+" dy="+dy);
   //println("dy="+dy+" dx="+dx+" angleRad="+ angleRadians+" angleDeg="+angleDegrees+" heading="+heading);
   
   return[dist,heading];
}


}
  
  
</script>

</Body>
</HTML>
